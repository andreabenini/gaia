#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
import os
from socket import send_fds
from ssl import Purpose
import sys
try:
    import ssl
    import yaml
    import socket
    import argparse
except ModuleNotFoundError as E:
    print(f"{E}. Install required module.")
    sys.exit(1)

class botCtl:
    @property
    def valid(self):
        return self.__valid
    @property
    def debug(self):
        return self.__debug
    @debug.setter
    def debug(self, boolValue):
        if isinstance(boolValue, (bool)):
            self.__debug = boolValue
        else:
            self.__debug = False
    def __debugPrint(self, message=None):
        if self.debug:
            print(f"DEBUG>  {message}")
    def __error(self, message=None):
        print(message)
        sys.exit(1)

    # Load SSL context
    def __loadSSL(self):
        try:
            # self.__context = ssl.SSLContext()
            self.__context = ssl.create_default_context(purpose=ssl.Purpose.SERVER_AUTH, cafile=self.__caCertificate)
            self.__context.verify_mode = ssl.CERT_REQUIRED
            # self.__context.load_verify_locations(self.__caCertificate)     # CA certificate with which the client will validate the server certificate
            self.__context.load_cert_chain(certfile=self.__clientCertificate, keyfile=self.__clientKey)  # Load client certificate
            # context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1  # optional
            # self.__context.check_hostname = False
        except Exception as E:
            self.__error(str(E))

    # TCP client connection method
    def __connect(self, host=None, port=None):
        try:
            print(f"Trying {host}:{port}...")
            self.__clientSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.__socket = self.__context.wrap_socket(self.__clientSocket)  #, server_hostname=self.__host)
            self.__socket.connect((host, port))

            # TODO: self.__clientSocket.close(), self.__socket.close()


            # DEBUG: printme and remove later
            server_cert = self.__socket.getpeercert()       # Obtain certificate from server
            if not server_cert:
                raise Exception('Unable to retrieve server certificate')
            print(server_cert)

        except Exception as E:
            self.__error(str(E))

    # Constructor
    def __init__(self, configuration=None, debug=False):
        self.__valid = False
        try:
            # yaml loading
            fHandler = open(configuration)
            if not fHandler: raise Exception(f"Cannot open '{configuration}' file")
            config = yaml.safe_load(fHandler)
            fHandler.close()
            if 'botserverHost' not in config: raise Exception("[botserverHost] not found in configuration file")
            if 'botserverPort' not in config: raise Exception("[botserverPort] not found in configuration file")
            self.__host = config['botserverHost']
            self.__port = int(config['botserverPort'])
            self.debug = debug

            # Certification files checkings
            dirCertificates = os.path.dirname(configuration)
            dirCertificates = ('.' if dirCertificates=='' else dirCertificates) + os.path.sep + 'certs' + os.path.sep
            self.__caCertificate     = self.__checkFile(dirCertificates, "ca_cert.pem")
            self.__clientCertificate = self.__checkFile(dirCertificates, "client_cert.pem")
            self.__clientKey         = self.__checkFile(dirCertificates, "client_key.pem")
            self.__valid = True
        except Exception as e:
            self.__error(str(e))

    def __checkFile(self, dir, filename):
        if os.path.exists(dir + filename):
            return dir+filename
        else:
            raise Exception(f"File  {dir}{filename}  not found")


    def start(self):
        self.__loadSSL()
        self.__connect(host=self.__host, port=self.__port)
        print(f"Connected to {self.__host}:{self.__port}\n")
        cmd = None
        while cmd!='exit' and cmd!='sys,exit' and cmd!='sys,shutdown':
            try:
                cmd = input("> ").strip()
                if cmd!=None and cmd!='' and cmd!='exit':
                    self.__socket.send((cmd+'\n').encode('UTF-8'))
                    msg = self.__socket.recv(1024)
                    if msg:
                        msg = msg.decode('UTF-8').strip()
                        print(msg)
            except socket.error:
                self.__error(f"Cannot send '{cmd}'")


if __name__ == '__main__':
    try:
        # Parsing command line params
        parser = argparse.ArgumentParser(description='Bot command line interface')
        parser.add_argument('-d', '--debug',  dest='debug',   action='store_true', help='Turn on debugging')
        parser.add_argument('-c', '--configuration', metavar='CONFIG', type=str,   help='Client configuration file [default: config.yaml]', default='config.yaml')
        parser.set_defaults(debug=False)
        args = parser.parse_args()

        # Command line interface console startup
        botCommandLine = botCtl(configuration=args.configuration, debug=args.debug)
        if botCommandLine.valid:
            botCommandLine.start()
    except KeyboardInterrupt:
        print("\nInterrupt request, utility aborted\n")
